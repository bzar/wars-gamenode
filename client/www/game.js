// Generated by CoffeeScript 1.6.3
(function() {
  require(["Theme", "AnimatedMap", "GameLogic", "Color", "gamenode", "base", "lib/d3/d3", "ticker.js"], function(Theme, AnimatedMap, GameLogic, Color) {
    var clampElement, client, finalizeTurn, finished, fitElement, formatTime, gameClient, gameId, gameLogic, gameMap, gameUIState, getPowerMap, handleActionMapClick, handleAttackMapClick, handleMapClick, handleMoveMapClick, handleSelectMapClick, handleShowRangeMapClick, handleUnloadTargetMapClick, handleUnloadUnitMapClick, inTurn, inTurnNumber, initializeAuthorTools, initializeGame, initializeGameTools, initializeMenuControls, initializeMessageTicker, initializePlayers, initializeTurn, map, powerMap, refreshFunds, session, setMenubarToPlayerColor, showActionMenu, showBuildMenu, showGame, showUnloadMenu, switchToActionState, theme, ticker, turnCounter, undoMove, updateStatistic;
    client = new GameNodeClient(Skeleton);
    gameClient = client;
    session = null;
    inTurn = false;
    inTurnNumber = 0;
    gameLogic = null;
    theme = null;
    map = null;
    ticker = null;
    turnCounter = null;
    powerMap = null;
    finished = false;
    gameClient = null;
    gameMap = null;
    gameUIState = {
      stateName: "select"
    };
    gameId = /[?&]gameId=([0-9a-f]+)/.exec(window.location.search);
    if (gameId !== null) {
      gameId = gameId[1];
    } else {
      document.location = "/";
    }
    $(document).ready(function() {
      var loginUrl;
      loginUrl = "login.html?next=" + document.location.pathname + document.location.search;
      return session = resumeSessionOrRedirect(client, WARS_CLIENT_SETTINGS.gameServer, loginUrl, function() {
        client.stub.subscribeGame(gameId);
        populateNavigation(session);
        if (gameId !== null) {
          return client.stub.gameData(gameId, function(response) {
            if (response.success) {
              if (response.game.state === "pregame") {
                document.location = "pregame.html?gameId=" + gameId;
              }
              $("#spinner").show();
              initializeChat(client, gameId);
              initializeMenuControls();
              initializeGameTools();
              $("#round").text(response.game.roundNumber);
              if (response.author) {
                initializeAuthorTools();
              } else {
                $("#authorTools").hide();
              }
              return initializeGame(response.game, response.author, response.turnRemaining);
            } else {
              return alert("Error loading game!");
            }
          });
        }
      });
    });
    initializeMenuControls = function() {
      return $("#gameStatistics").attr("href", "gamestatistics.html?gameId=" + gameId);
    };
    refreshFunds = function() {
      return client.stub.myFunds(gameId, function(response) {
        if (response.success) {
          return $("#funds").text(response.funds);
        } else {
          return $("#funds").text("N/A");
        }
      });
    };
    initializeGameTools = function() {
      var speeds;
      $("#endTurn").click(function(e) {
        e.preventDefault();
        undoMove();
        $("#spinner").show();
        return client.stub.endTurn(gameId, function(response) {
          if (!response.success) {
            alert(response.reason);
            return $("#spinner").hide();
          }
        });
      });
      $("#surrender").click(function(e) {
        e.preventDefault();
        if (window.confirm("Are you sure you want to SURRENDER? This means you LOSE the game.")) {
          $("#spinner").show();
          return client.stub.surrender(gameId, function(response) {
            if (!response.success) {
              alert("Could not surrender! " + response.reason);
              return $("#spinner").hide();
            }
          });
        }
      });
      $("#leaveGame").click(function(e) {
        e.preventDefault();
        if (window.confirm("Are you sure you want to leave the game?")) {
          $("#spinner").show();
          return client.stub.leaveGame(gameId, inTurnNumber, function(response) {
            if (!response.success) {
              alert("Could not leave game! " + response.reason);
              return $("#spinner").hide();
            } else {
              return document.location = "home.html";
            }
          });
        }
      });
      client.stub.emailNotifications(gameId, function(response) {
        if (response.success) {
          if (response.value) {
            return $("#sendNotificationsStatus").text("off");
          }
        } else {
          return $("#sendNotifications").hide();
        }
      });
      $("#sendNotifications").click(function(e) {
        var nextValue, status;
        e.preventDefault();
        status = $("#sendNotifications i");
        nextValue = !status.hasClass("icon-check");
        return client.stub.setEmailNotifications(gameId, nextValue, function(response) {
          if (response.success) {
            status.removeClass((nextValue ? "icon-check-empty" : "icon-check"));
            return status.addClass((nextValue ? "icon-check" : "icon-check-empty"));
          } else {
            return alert("Could not change email notifications setting! " + response.reason);
          }
        });
      });
      speeds = [
        {
          x: "1",
          t: "1x"
        }, {
          x: "1.5",
          t: "1.5x"
        }, {
          x: "2",
          t: "2x"
        }, {
          x: "3",
          t: "3x"
        }, {
          x: "4",
          t: "4x"
        }, {
          x: "5",
          t: "5x"
        }, {
          x: "0",
          t: "off"
        }
      ];
      $("#animationSpeedPlus").click(function(e) {
        var current, i, speed, _i, _len, _results;
        current = $("#animationSpeed").text();
        _results = [];
        for (i = _i = 0, _len = speeds.length; _i < _len; i = ++_i) {
          speed = speeds[i];
          if (speed.t === current) {
            if (i < speeds.length - 1) {
              map.animationSpeed = speeds[i + 1].x;
              map.animate = map.animationSpeed !== 0;
              _results.push($("#animationSpeed").text(speeds[i + 1].t));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      return $("#animationSpeedMinus").click(function(e) {
        var current, i, speed, _i, _len, _results;
        current = $("#animationSpeed").text();
        _results = [];
        for (i = _i = 0, _len = speeds.length; _i < _len; i = ++_i) {
          speed = speeds[i];
          if (speed.t === current) {
            if (i > 0) {
              map.animationSpeed = speeds[i - 1].x;
              map.animate = map.animationSpeed !== 0;
              _results.push($("#animationSpeed").text(speeds[i - 1].t));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };
    initializeAuthorTools = function() {};
    formatTime = function(t) {
      var h, m, s, sec;
      s = "";
      if (t >= 60 * 60) {
        h = Math.floor(t / (60 * 60));
        if (h < 10) {
          s += 0;
        }
        s += h + ":";
      }
      if (t >= 60) {
        m = Math.floor(t / 60) % 60;
        if (m < 10) {
          s += 0;
        }
        s += m + ":";
      }
      sec = Math.ceil(t) % 60;
      if (sec < 10) {
        s += 0;
      }
      s += sec;
      return s;
    };
    setMenubarToPlayerColor = function(playerNumber) {
      var barColor, c, hsl, playerColor;
      c = theme.getPlayerColor(inTurnNumber);
      playerColor = Color.fromRgb(c.r, c.g, c.b);
      hsl = playerColor.toHsl();
      barColor = Color.fromHsl(hsl[0], hsl[1], 0.3);
      return $("#menubar").css("background-color", barColor.toString());
    };
    initializeGame = function(game, author, turnRemaining) {
      showGame(game, author, turnRemaining);
      client.skeleton.gameTurnChange = function(gameId, newTurn, newRound, turnRemaining) {
        var playerInTurn;
        $("#round").text(newRound);
        inTurnNumber = newTurn;
        $(".playerItem.inTurn").removeClass("inTurn");
        playerInTurn = $(".playerItem[playerNumber=\"" + inTurnNumber + "\"]");
        playerInTurn.addClass("inTurn");
        setMenubarToPlayerColor(inTurnNumber);
        if (playerInTurn.hasClass("isMe")) {
          initializeTurn();
        } else {
          finalizeTurn();
        }
        turnCounter = turnRemaining;
        return updateStatistic();
      };
      client.skeleton.gameFinished = function(gameId) {
        $("#leaveGame").show();
        finalizeTurn();
        return finished = true;
      };
      return $("#mapCanvas").click(handleMapClick);
    };
    showGame = function(game, author, turnRemaining) {
      $("#gameName").text(game.name);
      finished = game.state === "finished";
      if (!finished) {
        $("#leaveGame").hide();
      }
      if (turnRemaining === null) {
        $("#turnTimeItem").hide();
      } else {
        turnCounter = turnRemaining;
        setInterval((function() {
          $("#turnTime").text(formatTime(turnCounter));
          return turnCounter = (turnCounter > 0 ? turnCounter - 1 : 0);
        }), 1000);
      }
      return client.stub.profile(function(response) {
        theme = new Theme(response.profile.settings.gameTheme);
        return theme.load(function() {
          updateStatistic();
          return client.stub.gameRules(gameId, function(rules) {
            map = new AnimatedMap("mapCanvas", 1.0, theme, rules);
            map.players = game.players;
            gameLogic = new GameLogic(map, rules);
            gameMap = map;
            return map.doPreload(function() {
              var mapSize;
              inTurnNumber = game.inTurnNumber;
              setMenubarToPlayerColor(inTurnNumber);
              initializePlayers(game.players);
              initializeMessageTicker();
              refreshFunds();
              map.tiles = game.tiles;
              mapSize = map.getMapDimensions();
              map.resize(mapSize.e(1), mapSize.e(2));
              map.refresh();
              map.initEntities();
              if (response.profile.settings.animationSpeed == null) {
                map.animationSpeed = 1;
                map.animate = true;
                $("#animationSpeed").text("1x");
              } else if (response.profile.settings.animationSpeed > 0) {
                map.animationSpeed = parseFloat(response.profile.settings.animationSpeed);
                $("#animationSpeed").text(response.profile.settings.animationSpeed + "x");
              } else {
                map.animate = false;
                $("#animationSpeed").text("off");
              }
              return $("#spinner").hide();
            });
          });
        });
      });
    };
    initializeMessageTicker = function() {
      var messageTicker, messageTickerContainer, queue;
      ticker = new MessageTicker($("#messageTicker"), map);
      messageTicker = $("#messageTicker");
      messageTickerContainer = $("#messageTickerContainer");
      queue = [];
      client.skeleton.gameEvents = function(gameId, events) {
        var alreadyProcessing, event, processEvents, _i, _len;
        processEvents = function(callback) {
          var e, nextEvent;
          nextEvent = function() {
            if (queue.length !== 0) {
              return processEvents(callback);
            } else {
              return callback();
            }
          };
          e = queue.shift();
          if (e.content != null) {
            e = e.content;
          }
          switch (e.action) {
            case "move":
              return map.moveUnit(e.unit.unitId, e.tile.tileId, e.path, nextEvent);
            case "wait":
              return map.waitUnit(e.unit.unitId, nextEvent);
            case "attack":
              return map.attackUnit(e.attacker.unitId, e.target.unitId, e.damage, nextEvent);
            case "counterattack":
              return map.counterattackUnit(e.attacker.unitId, e.target.unitId, e.damage, nextEvent);
            case "capture":
              return map.captureTile(e.unit.unitId, e.tile.tileId, e.left, nextEvent);
            case "captured":
              return map.capturedTile(e.unit.unitId, e.tile.tileId, nextEvent);
            case "deploy":
              return map.deployUnit(e.unit.unitId, nextEvent);
            case "undeploy":
              return map.undeployUnit(e.unit.unitId, nextEvent);
            case "load":
              return map.loadUnit(e.unit.unitId, e.carrier.unitId, nextEvent);
            case "unload":
              return map.unloadUnit(e.unit.unitId, e.carrier.unitId, e.tile.tileId, nextEvent);
            case "destroyed":
              return map.destroyUnit(e.unit.unitId, nextEvent);
            case "repair":
              return map.repairUnit(e.unit.unitId, e.newHealth, nextEvent);
            case "build":
              return map.buildUnit(e.tile.tileId, e.unit, nextEvent);
            case "regenerateCapturePoints":
              return map.regenerateCapturePointsTile(e.tile.tileId, e.newCapturePoints, nextEvent);
            case "produceFunds":
              return map.produceFundsTile(e.tile.tileId, nextEvent);
            case "beginTurn":
              return map.beginTurn(e.player, nextEvent);
            case "endTurn":
              return map.endTurn(e.player, nextEvent);
            case "turnTimeout":
              return map.turnTimeout(e.player, nextEvent);
            case "finished":
              return map.finished(e.winner, nextEvent);
            case "surrender":
              return map.surrender(e.player, nextEvent);
          }
        };
        alreadyProcessing = queue.length !== 0;
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          event = events[_i];
          queue.push(event);
        }
        $("#spinner").hide();
        ticker.showMessages(events);
        if (messageTickerContainer.css("display") === "none") {
          $("#showMessageTicker").addClass("highlight");
        }
        if (!alreadyProcessing) {
          return processEvents(function() {});
        }
      };
      client.stub.gameEvents(gameId, 0, 10, function(response) {
        if (!response.success) {
          return alert("Could not get game events! " + response.reason);
        } else {
          return ticker.setMessages(response.gameEvents, true);
        }
      });
      $("#showHideMessageTicker").click(function(e) {
        e.preventDefault();
        if (messageTicker.hasClass("small")) {
          messageTicker.removeClass("small");
          $("#content").css("bottom", messageTickerContainer.outerHeight());
        } else {
          messageTicker.addClass("small");
          $("#content").css("bottom", messageTickerContainer.outerHeight());
        }
        return messageTicker.scrollTop(0);
      });
      $("#showMessageTicker").click(function(e) {
        e.preventDefault();
        messageTickerContainer.toggle();
        if (messageTickerContainer.css("display") === "none") {
          $("#showMessageTickerStatus").text("Show");
          return $("#content").css("bottom", 0);
        } else {
          $("#showMessageTickerStatus").text("Hide");
          $("#showMessageTicker").removeClass("highlight");
          return $("#content").css("bottom", messageTickerContainer.outerHeight());
        }
      });
      return messageTicker.scroll(function(e) {
        if ($(this).scrollTop() + $(this).innerHeight() >= this.scrollHeight - 16) {
          return client.stub.gameEvents(gameId, messageTicker.children().length, 10, function(response) {
            if (!response.success) {
              return alert("Could not get game events! " + response.reason);
            } else {
              return ticker.showOldMessages(response.gameEvents);
            }
          });
        }
      });
    };
    initializePlayers = function(players) {
      var c, count, counts, i, item, name, number, player, playerList, playerTeams, showTeams, star, team, _i, _len, _results;
      players.sort(function(a, b) {
        return a.playerNumber - b.playerNumber;
      });
      playerList = $("#players");
      i = 0;
      playerTeams = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = players.length; _i < _len; _i++) {
          player = players[_i];
          _results.push(player.teamNumber);
        }
        return _results;
      })();
      count = function(item, items) {
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = items.length; _i < _len; _i++) {
            i = items[_i];
            if (i === item) {
              _results.push(i);
            }
          }
          return _results;
        })()).length;
      };
      counts = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = playerTeams.length; _i < _len; _i++) {
          team = playerTeams[_i];
          _results.push(count(team, playerTeams));
        }
        return _results;
      })();
      showTeams = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = counts.length; _i < _len; _i++) {
          c = counts[_i];
          if (c > 1) {
            _results.push(c);
          }
        }
        return _results;
      })()).length > 0;
      _results = [];
      for (_i = 0, _len = players.length; _i < _len; _i++) {
        player = players[_i];
        if (player.playerName === null) {
          continue;
        }
        item = $("<li></li>");
        number = $("<span></span>");
        name = $("<span></span>");
        item.addClass("playerItem");
        if (player.playerNumber === inTurnNumber) {
          item.addClass("inTurn");
          if (player.isMe && !finished) {
            initializeTurn(player.playerNumber);
          } else {
            finalizeTurn();
          }
        }
        if (player.isMe) {
          item.addClass("isMe");
        }
        item.attr("playerNumber", player.playerNumber);
        number.text(player.playerNumber);
        number.css("background-color", theme.getPlayerColorString(player.playerNumber));
        number.addClass("playerNumber");
        if (player.playerName != null) {
          name.text(player.playerName);
        }
        name.addClass("playerName");
        item.append(number);
        item.append(name);
        if (showTeams) {
          team = $("<span></span>");
          team.text(" (" + player.teamNumber + ")");
          item.append(team);
        }
        if (player.isMe) {
          star = $("<span>★</span>");
          star.addClass("selfIndicator");
          item.append(star);
        }
        _results.push(playerList.append(item));
      }
      return _results;
    };
    initializeTurn = function() {
      inTurn = true;
      refreshFunds();
      return $(".turnAction").show();
    };
    finalizeTurn = function() {
      inTurn = false;
      refreshFunds();
      return $(".turnAction").hide();
    };
    handleMapClick = function(e) {
      var buildMenu, canvas, canvasPosition, content, hexCoords, tilePosition, windowPosition;
      if (finished) {
        return;
      }
      buildMenu = $("#buildMenu");
      canvas = $("#mapCanvas");
      content = $("#content");
      canvasPosition = {
        x: e.pageX - e.currentTarget.offsetLeft,
        y: e.pageY - e.currentTarget.offsetTop
      };
      windowPosition = {
        x: e.pageX,
        y: e.pageY
      };
      hexCoords = map.coordToTile(canvasPosition.x, canvasPosition.y);
      tilePosition = {
        x: hexCoords.e(1),
        y: hexCoords.e(2)
      };
      if (inTurn) {
        buildMenu.hide();
        switch (gameUIState.stateName) {
          case "select":
            return handleSelectMapClick(tilePosition, canvasPosition);
          case "move":
            return handleMoveMapClick(tilePosition, canvasPosition);
          case "action":
            return handleActionMapClick();
          case "attack":
            return handleAttackMapClick(tilePosition);
          case "unloadUnit":
            return handleUnloadUnitMapClick();
          case "unloadTarget":
            return handleUnloadTargetMapClick(tilePosition);
          case "showRange":
            return handleShowRangeMapClick();
        }
      } else {
        switch (gameUIState.stateName) {
          case "select":
            return handleSelectMapClick(tilePosition, canvasPosition);
          case "showRange":
            return handleShowRangeMapClick();
        }
      }
    };
    handleSelectMapClick = function(tilePosition, canvasPosition) {
      var buildOptions, movementOptions;
      if (inTurn && gameLogic.tileHasMovableUnit(inTurnNumber, tilePosition.x, tilePosition.y)) {
        movementOptions = gameLogic.unitMovementOptions(tilePosition.x, tilePosition.y);
        map.paintMovementMask(movementOptions);
        if (movementOptions.length > 1) {
          return gameUIState = {
            stateName: "move",
            x: tilePosition.x,
            y: tilePosition.y,
            movementOptions: movementOptions
          };
        } else {
          map.hideOverlay();
          return switchToActionState(tilePosition.x, tilePosition.y, tilePosition.x, tilePosition.y, [
            {
              x: tilePosition.x,
              y: tilePosition.y
            }
          ], movementOptions, canvasPosition);
        }
      } else if (inTurn && gameLogic.tileCanBuild(inTurnNumber, tilePosition.x, tilePosition.y)) {
        buildOptions = gameLogic.tileBuildOptions(tilePosition.x, tilePosition.y);
        return showBuildMenu(buildOptions, canvasPosition, tilePosition);
      } else if (map.getTile(tilePosition.x, tilePosition.y).unit !== null) {
        gameUIState = {
          stateName: "showRange"
        };
        movementOptions = gameLogic.unitMovementOptions(tilePosition.x, tilePosition.y);
        return map.paintMovementMask(movementOptions);
      }
    };
    handleMoveMapClick = function(tilePosition, canvasPosition) {
      var canMove, dx, dy, node, option, path, unitId, x, y, _i, _len, _ref;
      map.refresh();
      x = gameUIState.x;
      y = gameUIState.y;
      dx = tilePosition.x;
      dy = tilePosition.y;
      canMove = false;
      path = null;
      _ref = gameUIState.movementOptions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (option.pos.x === dx && option.pos.y === dy) {
          canMove = true;
          node = option;
          path = [node.pos];
          while (node.prev) {
            path.push(node.prev.pos);
            node = node.prev;
          }
          path.reverse();
          break;
        }
      }
      if (!canMove) {
        gameUIState = {
          stateName: "select"
        };
        return map.refresh();
      } else {
        unitId = map.getTile(gameUIState.x, gameUIState.y).unit.unitId;
        return map.showMoveUnit(unitId, path, function() {
          return switchToActionState(x, y, dx, dy, path, gameUIState.movementOptions, canvasPosition);
        });
      }
    };
    handleShowRangeMapClick = function() {
      gameUIState = {
        stateName: "select"
      };
      return map.refresh();
    };
    handleActionMapClick = function() {
      return undoMove();
    };
    handleAttackMapClick = function(tilePosition) {
      var canAttack, destination, option, targetId, tx, ty, unitId, _i, _len, _ref;
      map.refresh();
      map.hideOverlay();
      tx = tilePosition.x;
      ty = tilePosition.y;
      canAttack = false;
      _ref = gameUIState.attackOptions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (parseInt(option.pos.x) === tx && parseInt(option.pos.y) === ty) {
          canAttack = true;
          break;
        }
      }
      if (canAttack) {
        unitId = map.getTile(gameUIState.x, gameUIState.y).unit.unitId;
        destination = {
          x: gameUIState.dx,
          y: gameUIState.dy
        };
        targetId = map.getTile(tx, ty).unit.unitId;
        $("#spinner").show();
        return client.stub.moveAndAttack(gameId, unitId, destination, gameUIState.path, targetId, function(response) {
          if (!response.success) {
            alert(response.reason);
          }
          return gameUIState = {
            stateName: "select"
          };
        });
      } else {
        return undoMove();
      }
    };
    handleUnloadUnitMapClick = function() {
      return undoMove();
    };
    handleUnloadTargetMapClick = function(tilePosition) {
      var canUnload, carriedUnitId, destination, option, tx, ty, unitId, unloadDestination, _i, _len, _ref;
      map.refresh();
      map.hideOverlay();
      tx = tilePosition.x;
      ty = tilePosition.y;
      canUnload = false;
      _ref = gameUIState.unloadTargetOptions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (option.x === tx && option.y === ty) {
          canUnload = true;
          break;
        }
      }
      if (canUnload) {
        unitId = map.getTile(gameUIState.x, gameUIState.y).unit.unitId;
        destination = {
          x: gameUIState.dx,
          y: gameUIState.dy
        };
        carriedUnitId = gameUIState.carriedUnitId;
        unloadDestination = {
          x: tx,
          y: ty
        };
        $("#spinner").show();
        return client.stub.moveAndUnload(gameId, unitId, destination, gameUIState.path, carriedUnitId, unloadDestination, function(response) {
          if (!response.success) {
            alert(response.reason);
          }
          return gameUIState = {
            stateName: "select"
          };
        });
      } else {
        return undoMove();
      }
    };
    undoMove = function() {
      var tile, unitId;
      if (gameUIState.stateName !== "select") {
        tile = map.getTile(gameUIState.x, gameUIState.y);
        if (tile && tile.unit && gameUIState.path) {
          unitId = tile.unit.unitId;
          gameUIState.path.reverse();
          map.showMoveUnit(unitId, gameUIState.path);
        }
      }
      gameUIState = {
        stateName: "select"
      };
      map.refresh();
      map.hideOverlay();
      $("#actionMenu").hide();
      $("#unloadMenu").hide();
      return $("#buildMenu").hide();
    };
    switchToActionState = function(x, y, dx, dy, path, movementOptions, canvasPosition) {
      var actions;
      gameUIState = {
        stateName: "action",
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        path: path
      };
      actions = [];
      if (gameLogic.unitCanLoadInto(x, y, dx, dy)) {
        actions.push("load");
      } else {
        if (gameLogic.unitCanUnload(x, y, dx, dy)) {
          actions.push("unload");
        }
        if (gameLogic.unitAttackOptions(x, y, dx, dy).length > 0) {
          actions.push("attack");
        }
        if (gameLogic.unitCanCapture(x, y, dx, dy)) {
          actions.push("capture");
        }
        if (gameLogic.unitCanDeploy(x, y, dx, dy)) {
          actions.push("deploy");
        }
        if (gameLogic.unitCanUndeploy(x, y, dx, dy)) {
          actions.push("undeploy");
        }
        if (gameLogic.unitCanWait(x, y, dx, dy)) {
          actions.push("wait");
        }
      }
      actions.push("cancel");
      return showActionMenu(actions, canvasPosition);
    };
    fitElement = function(numItems, itemWidth, itemHeight, content) {
      var gridHeight, gridOptimalHeight, gridOptimalWidth, gridWidth, height, maxHeight, maxWidth, optimalHeight, optimalWidth, width;
      gridOptimalWidth = Math.ceil(Math.sqrt(numItems));
      gridOptimalHeight = Math.ceil(numItems / gridOptimalWidth);
      optimalWidth = itemWidth * gridOptimalWidth;
      optimalHeight = itemHeight * gridOptimalHeight;
      maxWidth = content.width();
      maxHeight = content.height();
      width = optimalWidth;
      height = optimalHeight;
      if (width > maxWidth) {
        gridWidth = parseInt(maxWidth / itemWidth);
        gridHeight = Math.ceil(numItems / gridWidth);
        width = gridWidth * itemWidth;
        height = gridHeight * itemHeight;
      }
      if (height > maxHeight) {
        height = maxHeight;
      }
      return {
        width: width,
        height: height
      };
    };
    clampElement = function(left, top, width, height, content) {
      var maxBottom, maxRight, minLeft, minTop;
      minLeft = content.scrollLeft();
      minTop = content.scrollTop();
      maxRight = content.scrollLeft() + content.width();
      maxBottom = content.scrollTop() + content.height();
      if (left < minLeft) {
        left = minLeft;
      } else {
        if (left + width > maxRight) {
          left = maxRight - width;
        }
      }
      if (top < minTop) {
        top = minTop;
      } else {
        if (top + height > maxBottom) {
          top = maxBottom - height;
        }
      }
      return {
        left: left,
        top: top
      };
    };
    showActionMenu = function(actions, canvasPosition) {
      var action, actionMap, actionMenu, actionName, content, item, optimalLeft, optimalTop, position, size, _i, _len;
      actionMenu = $("#actionMenu");
      content = $("#content");
      size = fitElement(actions.length, 48, 48, content);
      optimalLeft = canvasPosition.x;
      optimalTop = canvasPosition.y;
      position = clampElement(optimalLeft, optimalTop, size.width, size.height, content);
      actionMenu.empty();
      actionMenu.width(size.width);
      actionMenu.height(size.height);
      actionMenu.css("left", position.left);
      actionMenu.css("top", position.top);
      actionMenu.show();
      actionMap = {
        attack: {
          img: theme.getAttackIconUrl(),
          name: "Attack",
          action: "attack"
        },
        deploy: {
          img: theme.getDeployIconUrl(),
          name: "Deploy",
          action: "deploy"
        },
        undeploy: {
          img: theme.getUndeployIconUrl(),
          name: "Undeploy",
          action: "undeploy"
        },
        capture: {
          img: theme.getCaptureIconUrl(),
          name: "Capture",
          action: "capture"
        },
        wait: {
          img: theme.getWaitIconUrl(),
          name: "Wait",
          action: "wait"
        },
        load: {
          img: theme.getLoadIconUrl(),
          name: "Load",
          action: "load"
        },
        unload: {
          img: theme.getUnloadIconUrl(),
          name: "Unload",
          action: "unload"
        },
        cancel: {
          img: theme.getCancelIconUrl(),
          name: "Cancel",
          action: "cancel"
        }
      };
      for (_i = 0, _len = actions.length; _i < _len; _i++) {
        actionName = actions[_i];
        action = actionMap[actionName];
        item = $("<img></img>");
        item.addClass("actionItem");
        item.attr("src", action.img);
        item.attr("alt", action.name);
        item.attr("action", action.action);
        actionMenu.append(item);
      }
      return $(".actionItem").click(function(e) {
        var carrierId, destination, resetUI, unitId;
        resetUI = function(response) {
          if (!response.success) {
            alert(response.reason);
          }
          map.refresh();
          return gameUIState = {
            stateName: "select"
          };
        };
        action = $(this).attr("action");
        actionMenu.hide();
        switch (action) {
          case "cancel":
            return undoMove();
          case "attack":
            gameUIState = {
              stateName: "attack",
              attackOptions: gameLogic.unitAttackOptions(gameUIState.x, gameUIState.y, gameUIState.dx, gameUIState.dy),
              x: gameUIState.x,
              y: gameUIState.y,
              dx: gameUIState.dx,
              dy: gameUIState.dy,
              path: gameUIState.path
            };
            return map.paintAttackMask(gameUIState.attackOptions);
          case "wait":
            unitId = map.getTile(gameUIState.x, gameUIState.y).unit.unitId;
            destination = {
              x: gameUIState.dx,
              y: gameUIState.dy
            };
            $("#spinner").show();
            return client.stub.moveAndWait(gameId, unitId, destination, gameUIState.path, resetUI);
          case "capture":
            unitId = map.getTile(gameUIState.x, gameUIState.y).unit.unitId;
            destination = {
              x: gameUIState.dx,
              y: gameUIState.dy
            };
            $("#spinner").show();
            return client.stub.moveAndCapture(gameId, unitId, destination, gameUIState.path, resetUI);
          case "deploy":
            unitId = map.getTile(gameUIState.x, gameUIState.y).unit.unitId;
            destination = {
              x: gameUIState.dx,
              y: gameUIState.dy
            };
            $("#spinner").show();
            return client.stub.moveAndDeploy(gameId, unitId, destination, gameUIState.path, resetUI);
          case "undeploy":
            unitId = map.getTile(gameUIState.x, gameUIState.y).unit.unitId;
            $("#spinner").show();
            return client.stub.undeploy(gameId, unitId, resetUI);
          case "load":
            unitId = map.getTile(gameUIState.x, gameUIState.y).unit.unitId;
            carrierId = map.getTile(gameUIState.dx, gameUIState.dy).unit.unitId;
            $("#spinner").show();
            return client.stub.moveAndLoadInto(gameId, unitId, carrierId, gameUIState.path, resetUI);
          case "unload":
            gameUIState = {
              stateName: "unloadUnit",
              unloadOptions: gameLogic.unitUnloadOptions(gameUIState.x, gameUIState.y, gameUIState.dx, gameUIState.dy),
              x: gameUIState.x,
              y: gameUIState.y,
              dx: gameUIState.dx,
              dy: gameUIState.dy,
              path: gameUIState.path
            };
            return showUnloadMenu(gameUIState.unloadOptions, canvasPosition);
        }
      });
    };
    showUnloadMenu = function(units, canvasPosition) {
      var content, item, optimalLeft, optimalTop, pos, position, size, unit, unloadMenu, _i, _len;
      unloadMenu = $("#unloadMenu");
      content = $("#content");
      size = fitElement(units.length, theme.settings.image.width + 12, theme.settings.image.height + 12, content);
      optimalLeft = canvasPosition.x;
      optimalTop = canvasPosition.y;
      position = clampElement(optimalLeft, optimalTop, size.width, size.height, content);
      unloadMenu.empty();
      unloadMenu.width(size.width);
      unloadMenu.height(size.height);
      unloadMenu.css("left", position.left);
      unloadMenu.css("top", position.top);
      unloadMenu.show();
      for (_i = 0, _len = units.length; _i < _len; _i++) {
        unit = units[_i];
        item = $("<span></span>");
        item.css("background-image", "url('" + theme.getSpriteSheetUrl() + "')");
        item.addClass("sprite");
        item.css("width", theme.settings.image.width);
        item.css("height", theme.settings.image.height);
        pos = theme.getUnitCoordinates(unit.type, inTurnNumber);
        item.css("background-position", -pos.x + "px " + -pos.y + "px");
        item.addClass("unloadItem");
        item.attr("unitId", unit.unitId);
        unloadMenu.append(item);
      }
      return $(".unloadItem").click(function(e) {
        var carriedUnitId, unloadTargetOptions;
        carriedUnitId = $(this).attr("unitId");
        unloadTargetOptions = gameLogic.unitUnloadTargetOptions(gameUIState.x, gameUIState.y, gameUIState.dx, gameUIState.dy, carriedUnitId);
        gameUIState = {
          stateName: "unloadTarget",
          unloadTargetOptions: unloadTargetOptions,
          carriedUnitId: carriedUnitId,
          x: gameUIState.x,
          y: gameUIState.y,
          dx: gameUIState.dx,
          dy: gameUIState.dy,
          path: gameUIState.path
        };
        map.paintUnloadMask(unloadTargetOptions);
        return unloadMenu.hide();
      });
    };
    showBuildMenu = function(buildOptions, canvasPosition, tilePosition) {
      var buildItem, buildMenu, content, funds, optimalLeft, optimalTop, pos, position, size, unitImage, unitName, unitPrice, unitType, _i, _len, _results;
      buildMenu = $("#buildMenu");
      content = $("#content");
      size = fitElement(buildOptions.length, 140, 140, content);
      optimalLeft = canvasPosition.x - size.width / 2;
      optimalTop = canvasPosition.y - size.height / 2;
      position = clampElement(optimalLeft, optimalTop, size.width, size.height, content);
      buildMenu.empty();
      buildMenu.width(size.width);
      buildMenu.height(size.height);
      buildMenu.css("left", position.left);
      buildMenu.css("top", position.top);
      buildMenu.show();
      _results = [];
      for (_i = 0, _len = buildOptions.length; _i < _len; _i++) {
        unitType = buildOptions[_i];
        buildItem = $("<span></span>");
        buildItem.addClass("buildItem");
        buildItem.attr("unitTypeId", unitType.id);
        unitPrice = $("<span></span>");
        unitPrice.text(unitType.price);
        unitPrice.addClass("price");
        unitName = $("<span></span>");
        unitName.text(unitType.name);
        unitName.addClass("name");
        unitImage = $("<div></div>");
        unitImage.css("background-image", "url('" + theme.getSpriteSheetUrl() + "')");
        unitImage.addClass("sprite");
        pos = theme.getUnitCoordinates(unitType.id, inTurnNumber);
        unitImage.css("background-position", -pos.x + "px " + -pos.y + "px");
        unitImage.css("width", theme.settings.image.width);
        unitImage.css("height", theme.settings.image.height);
        buildItem.append(unitPrice);
        buildItem.append(unitImage);
        buildItem.append(unitName);
        funds = parseInt($("#funds").text());
        if (parseInt(unitType.price) <= funds) {
          buildItem.click(function() {
            var unitTypeId;
            unitTypeId = parseInt($(this).attr("unitTypeId"));
            $("#spinner").show();
            return client.stub.build(gameId, unitTypeId, {
              x: tilePosition.x,
              y: tilePosition.y
            }, function(response) {
              if (response.success) {
                refreshFunds();
              } else {
                alert("Error building unit! " + response.reason);
              }
              return buildMenu.hide();
            });
          });
        } else {
          buildItem.addClass("disabled");
        }
        _results.push(buildMenu.append(buildItem));
      }
      return _results;
    };
    updateStatistic = function() {
      return client.stub.gameLatestStatistic(gameId, function(response) {
        var addChart, container, data, latestStatistic;
        addChart = function(container, data, property, icon) {
          var chart, height, scale, totalValue, width;
          chart = container.append("div").attr("class", "statisticBarChart").attr("chartProperty", property);
          chart.append("div").attr("class", "label").append("i").attr("class", "icon-" + icon);
          width = $(".statisticBarChart[chartProperty=\"" + property + "\"]").innerWidth() - 10;
          height = 8;
          totalValue = d3.sum(data, function(d) {
            return d[property];
          });
          scale = d3.scale.linear().domain([0, totalValue]).range(["0px", width + "px"]);
          return chart.selectAll(".bar").data(data).enter().append("div").style("width", function(d) {
            var foo;
            foo = scale(d[property]);
            return foo;
          }).style("height", height + "px").style("background-color", function(d) {
            return theme.getPlayerColorString(d.playerNumber);
          }).attr("class", function(d) {
            return "bar";
          }).attr("title", function(d) {
            return Math.round(100 * d[property] / totalValue) + "%";
          });
        };
        if (response.latestStatistic === null) {
          return;
        }
        latestStatistic = response.latestStatistic;
        container = d3.select("#gameStatistic");
        container.selectAll("div").remove();
        data = latestStatistic.content.sort(function(a, b) {
          return a.playerNumber - b.playerNumber;
        });
        addChart(container, data, "score", "trophy");
        addChart(container, data, "power", "chevron-up");
        return addChart(container, data, "property", "globe");
      });
    };
    return getPowerMap = function() {
      if (powerMap === null) {
        powerMap = gameLogic.getPowerMap();
      }
      return powerMap;
    };
  });

}).call(this);
