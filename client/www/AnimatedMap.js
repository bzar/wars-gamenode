// Generated by CoffeeScript 1.4.0
(function() {

  define(["Theme", "lib/aja/lib/aja", "lib/pixastic", "lib/sylvester"], function(Theme) {
    var AnimatedMap, CaptureBar, HealthIndicator, MapDigit, MapUnit, Overlay;
    AnimatedMap = (function() {

      function AnimatedMap(canvasId, scale, theme, rules) {
        this.theme = (theme ? theme : new Theme("pixel"));
        this.autoscale = !scale;
        this.scale = scale;
        this.canvas = new aja.Canvas(canvasId, !!this.theme.highDpiTheme);
        this.theme.setHighDpiCanvas(this.canvas.isHighDpiCanvas());
        this.canvas.verbosity = 1;
        this.overlay = new Overlay(this);
        this.overlay.z = 100;
        this.canvas.addEntity(this.overlay);
        this.overlay.visible = false;
        this.animationSpeed = 1.0;
        this.animate = true;
        this.canvas.renderOrder = function(a, b) {
          if (!(a.z != null)) {
            if (!(b.z != null)) {
              return (a.y + a.x / 2) - (b.y + b.x / 2);
            } else {
              return -b.z;
            }
          } else {
            if (!(b.z != null)) {
              return a.z;
            } else {
              return a.z - b.z;
            }
          }
        };
        this.xAxis = $V([this.theme.settings.hex.width - this.theme.settings.hex.triWidth, this.theme.settings.hex.height / 2]);
        this.yAxis = $V([0, this.theme.settings.hex.height]);
        this.origin = $V([0, this.theme.settings.image.height - this.theme.settings.hex.height]);
        this.tiles = null;
        this.sprites = null;
        this.players = null;
        this.rules = rules;
        this.powerMap = null;
        this.showPowerMap = false;
        this.showBorders = false;
        this.showGrid = false;
        this.unitEntities = {};
      }

      return AnimatedMap;

    })();
    AnimatedMap.PHASE_SELECT = 1;
    AnimatedMap.PHASE_MOVE = 2;
    AnimatedMap.PHASE_ATTACK = 3;
    AnimatedMap.PHASE_BUILD = 4;
    AnimatedMap.PHASE_ACTION = 5;
    AnimatedMap.PHASE_UNLOAD = 5;
    AnimatedMap.prototype.hex2rectCoords = function(hx, hy) {
      var p;
      p = (hy !== undefined ? $V([hx, hy]) : hx);
      p = this.xAxis.multiply(p.e(1)).add(this.yAxis.multiply(p.e(2)));
      p = p.add(this.origin);
      return p;
    };
    AnimatedMap.prototype.rect2hexCoords = function(rx, ry) {
      var mat, origin, p;
      p = (ry !== undefined ? $V([rx, ry]) : rx);
      p = p.subtract(this.origin);
      origin = $M([[1, 0, -this.theme.settings.hex.width / 2], [0, 1, -this.theme.settings.hex.height / 2], [0, 0, 1]]);
      mat = $M([[this.xAxis.e(1), this.yAxis.e(1), 0], [this.xAxis.e(2), this.yAxis.e(2), 0], [0, 0, 1]]).inv();
      return mat.multiply(origin.multiply($V([p.e(1), p.e(2), 1]))).round();
    };
    AnimatedMap.prototype.getPlayer = function(playerNumber) {
      var player, _i, _len, _ref;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.playerNumber === playerNumber) {
          return player;
        }
      }
      return null;
    };
    AnimatedMap.prototype.getScale = function() {
      var horScale, mapSize, verScale;
      if (this.autoscale) {
        mapSize = this.getMapDimensions();
        horScale = this.canvas.width / mapSize.e(1);
        verScale = this.canvas.height / mapSize.e(2);
        this.scale = (horScale < verScale ? horScale : verScale);
      }
      return this.scale;
    };
    AnimatedMap.prototype.getOffset = function() {
      var mapSize, xOffset, yOffset;
      if (this.autoscale) {
        mapSize = this.getMapDimensions();
        xOffset = (mapSize.w < mapSize.h ? (mapSize.h - mapSize.w) / 2 : 0);
        yOffset = (mapSize.w > mapSize.h ? (mapSize.w - mapSize.h) / 2 : 0);
        return $V([xOffset, yOffset]);
      } else {
        return $V([0, 0]);
      }
    };
    AnimatedMap.prototype.doPreload = function(callback) {
      var sprites, spritesAttack, spritesMoved, that;
      this.sprites = new Image();
      this.spritesMoved = new Image();
      this.spritesAttack = new Image();
      sprites = this.sprites;
      spritesMoved = this.spritesMoved;
      spritesAttack = this.spritesAttack;
      this.sprites.src = this.theme.getSpriteSheetUrl();
      that = this;
      return sprites.onload = function() {
        spritesMoved.src = sprites.src;
        return spritesMoved.onload = function() {
          return Pixastic.process(spritesMoved, "hsl", {
            hue: 0,
            saturation: -30,
            lightness: -30
          }, function(img) {
            that.spritesMoved = img;
            spritesAttack.src = sprites.src;
            return spritesAttack.onload = function() {
              return Pixastic.process(spritesAttack, "coloradjust", {
                red: 1.0,
                green: -0.2,
                blue: -0.2
              }, function(img) {
                that.spritesAttack = img;
                return callback();
              });
            };
          });
        };
      };
    };
    AnimatedMap.prototype.getMapLimits = function() {
      var max, min;
      min = null;
      max = null;
      this.tiles.forEach(function(tile) {
        if (min === null) {
          min = $V([tile.x, tile.y]);
          return max = $V([tile.x, tile.y]);
        } else {
          min = $V([(tile.x < min.e(1) ? tile.x : min.e(1)), (tile.y < min.e(2) ? tile.y : min.e(2))]);
          return max = $V([(tile.x > max.e(1) ? tile.x : max.e(1)), (tile.y > max.e(2) ? tile.y : max.e(2))]);
        }
      });
      return {
        min: min,
        max: max
      };
    };
    AnimatedMap.prototype.getMapSize = function() {
      var size;
      size = this.getMapLimits();
      return size.max.subtract(size.min);
    };
    AnimatedMap.prototype.getMapDimensions = function() {
      var h, rectSize, size, w;
      size = this.getMapLimits().max;
      w = this.hex2rectCoords(size.e(1) + 1, 0).e(1);
      h = this.hex2rectCoords(0, size.e(2) + 1).e(2);
      rectSize = $V([w, h]).add($V([this.theme.settings.hex.triWidth + this.origin.e(1), this.origin.e(2)]));
      return rectSize;
    };
    AnimatedMap.prototype.getTile = function(x, y) {
      var tiles;
      if (x !== undefined && y !== undefined) {
        return this.tiles.filter(function(d) {
          if (d.x === x && d.y === y) {
            return true;
          }
        })[0];
      } else if (x !== undefined) {
        tiles = this.tiles.filter(function(tile) {
          return tile.tileId === x;
        });
        if (tiles.length !== 0) {
          return tiles[0];
        } else {
          return null;
        }
      } else {
        return null;
      }
    };
    AnimatedMap.prototype.clear = function() {
      return this.canvas.ctx.clearRect(0, 0, this.canvas.canvas.width, this.canvas.canvas.height);
    };
    AnimatedMap.prototype._drawHex = function(ctx, tileType, tileSubtype, tileOwner, x, y, sheet) {
      var imageCoords;
      imageCoords = this.theme.getTileCoordinates(tileType, tileSubtype, tileOwner);
      return ctx.drawImage((sheet ? sheet : this.sprites), this.theme.getSheetCoordinate(imageCoords.x), this.theme.getSheetCoordinate(imageCoords.y), this.theme.getSheetCoordinate(this.theme.settings.image.width), this.theme.getSheetCoordinate(this.theme.settings.image.height), x, y, this.theme.settings.image.width, this.theme.settings.image.height);
    };
    AnimatedMap.prototype._drawProp = function(ctx, tileType, tileSubtype, tileOwner, x, y, sheet) {
      var imageCoords;
      imageCoords = this.theme.getTilePropCoordinates(tileType, tileSubtype, tileOwner);
      if (imageCoords === null) {
        return;
      }
      return ctx.drawImage((sheet ? sheet : this.sprites), this.theme.getSheetCoordinate(imageCoords.x), this.theme.getSheetCoordinate(imageCoords.y), this.theme.getSheetCoordinate(this.theme.settings.image.width), this.theme.getSheetCoordinate(this.theme.settings.image.height), x, y, this.theme.settings.image.width, this.theme.settings.image.height);
    };
    AnimatedMap.prototype._drawPropOnHex = function(ctx, tileType, tileSubtype, tileOwner, x, y, sheet) {
      return this._drawProp(ctx, tileType, tileSubtype, tileOwner, x, y - (this.theme.settings.image.height - this.theme.settings.hex.height), sheet);
    };
    AnimatedMap.prototype._redrawTerrain = function(ctx, redrawFunc) {
      var i, offset, r, tile, _results;
      i = 0;
      _results = [];
      while (i < this.tiles.length) {
        tile = this.tiles[i];
        if (tile) {
          r = this.hex2rectCoords(tile.x, tile.y);
          offset = this.theme.getTileOffset(tile.type, tile.subtype, tile.owner);
          if (redrawFunc) {
            redrawFunc(ctx, tile, r, offset);
          } else {
            this._drawHex(ctx, tile.type, tile.subtype, tile.owner, r.e(1), r.e(2) + offset);
            this._drawPropOnHex(ctx, tile.type, tile.subtype, tile.owner, r.e(1), r.e(2) + offset);
          }
        }
        _results.push(++i);
      }
      return _results;
    };
    AnimatedMap.prototype.paintMovementMask = function(movementOptions) {
      var ctx,
        _this = this;
      ctx = this.canvas.background.getContext("2d");
      this._redrawTerrain(ctx, function(ctx, tile, r, offset) {
        var i, sheet;
        sheet = _this.spritesMoved;
        i = 0;
        while (i < movementOptions.length) {
          if (movementOptions[i].pos.x === tile.x && movementOptions[i].pos.y === tile.y) {
            sheet = null;
            break;
          }
          ++i;
        }
        _this._drawHex(ctx, tile.type, tile.subtype, tile.owner, r.e(1), r.e(2) + offset, sheet);
        return _this._drawPropOnHex(ctx, tile.type, tile.subtype, tile.owner, r.e(1), r.e(2) + offset, sheet);
      });
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.paintUnloadMask = function(unloadOptions) {
      var ctx,
        _this = this;
      ctx = this.canvas.background.getContext("2d");
      this._redrawTerrain(ctx, function(ctx, tile, r, offset) {
        var option, sheet, _i, _len;
        sheet = _this.spritesMoved;
        for (_i = 0, _len = unloadOptions.length; _i < _len; _i++) {
          option = unloadOptions[_i];
          if (parseInt(option.x) === tile.x && parseInt(option.y) === tile.y) {
            sheet = null;
            break;
          }
        }
        _this._drawHex(ctx, tile.type, tile.subtype, tile.owner, r.e(1), r.e(2) + offset, sheet);
        return _this._drawPropOnHex(ctx, tile.type, tile.subtype, tile.owner, r.e(1), r.e(2) + offset, sheet);
      });
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.paintAttackMask = function(attackOptions) {
      var coord, ctx, damageString, i, n, numCoord, octx, opt, _i, _len,
        _this = this;
      ctx = this.canvas.background.getContext("2d");
      this._redrawTerrain(ctx, function(ctx, tile, r, offset) {
        var option, sheet, _i, _len;
        sheet = null;
        for (_i = 0, _len = attackOptions.length; _i < _len; _i++) {
          option = attackOptions[_i];
          if (parseInt(option.pos.x) === tile.x && parseInt(option.pos.y) === tile.y) {
            sheet = _this.spritesAttack;
            break;
          }
        }
        _this._drawHex(ctx, tile.type, tile.subtype, tile.owner, r.e(1), r.e(2) + offset, sheet);
        return _this._drawPropOnHex(ctx, tile.type, tile.subtype, tile.owner, r.e(1), r.e(2) + offset, sheet);
      });
      octx = this.overlay.canvas.getContext("2d");
      octx.clearRect(0, 0, octx.canvas.width, octx.canvas.height);
      for (_i = 0, _len = attackOptions.length; _i < _len; _i++) {
        opt = attackOptions[_i];
        damageString = "" + opt.power;
        coord = this.hex2rectCoords(opt.pos.x, opt.pos.y);
        i = 0;
        while (i < damageString.length) {
          n = damageString[i];
          numCoord = this.theme.getDamageNumberCoordinates(n);
          octx.drawImage(this.sprites, this.theme.getSheetCoordinate(numCoord.x), this.theme.getSheetCoordinate(numCoord.y), this.theme.getSheetCoordinate(this.theme.settings.image.width), this.theme.getSheetCoordinate(this.theme.settings.image.height), coord.e(1) - ((damageString.length - 1) / 2 - i) * (this.theme.settings.number.width + 1), coord.e(2) - (this.theme.settings.image.height - this.theme.settings.hex.height), this.theme.settings.image.width, this.theme.settings.image.height);
          ++i;
        }
      }
      this.overlay.visible = true;
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.sortTilesToRenderOrder = function() {
      return this.tiles.sort(function(a, b) {
        if (a.y !== b.y) {
          return a.y - b.y;
        } else {
          return a.x - b.x;
        }
      });
    };
    AnimatedMap.prototype.refresh = function() {
      var ctx, mapSize;
      this.sortTilesToRenderOrder();
      this.clear();
      if (!this.autoscale) {
        mapSize = this.getMapDimensions();
        this.canvas.width = mapSize.e(1);
        this.canvas.height = mapSize.e(2);
      }
      ctx = this.canvas.background.getContext("2d");
      ctx.fillStyle = "#eee";
      ctx.fillRect(0, 0, this.canvas.canvas.width, this.canvas.canvas.height);
      this._redrawTerrain(ctx);
      if (this.powerMap != null) {
        if (this.showPowerMap) {
          this.paintPowerMap(this.powerMap);
        }
        if (this.showBorders) {
          this.paintBorders(this.powerMap);
        }
      }
      if (this.showGrid) {
        this.paintGrid();
      }
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.coordToTile = function(cx, cy) {
      var offset, scale;
      offset = this.getOffset();
      scale = this.getScale();
      return this.rect2hexCoords((cx - offset.e(1)) / scale, (cy - offset.e(2)) / scale);
    };
    AnimatedMap.prototype.hideOverlay = function() {
      this.overlay.visible = false;
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.eventToTile = function(event) {
      var cx, cy;
      cx = event.pageX - $(this.canvas).offset().left;
      cy = event.pageY - $(this.canvas).offset().top;
      return coordToTile(cx, cy);
    };
    AnimatedMap.prototype.eventToTileX = function(event) {
      return this.eventToTile(event).e(1);
    };
    AnimatedMap.prototype.eventToTileY = function(event) {
      return this.eventToTile(event).e(2);
    };
    AnimatedMap.prototype.capturedPercentage = function(el) {
      return el.capturePoints / 200;
    };
    AnimatedMap.prototype.resize = function(width, height) {
      this.canvas.resize(width, height);
      return this.overlay.resize(width, height);
    };
    AnimatedMap.prototype.paintDamageIndicators = function(attacks) {
      var attack, ctx, mapSize, power, _i, _len;
      mapSize = this.getMapSize();
      ctx = this.overlay.canvas.getContext("2d");
      ctx.scale(this.getScale(), this.getScale());
      for (_i = 0, _len = attacks.length; _i < _len; _i++) {
        attack = attacks[_i];
        power = attack.power;
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 1;
        ctx.font = "15px sans-serif";
        ctx.textBaseline = "top";
        ctx.strokeText(power + "%", attack.pos.x * this.tileW + 2, attack.pos.y * this.tileH + 2 - this.unitOffsetY);
        ctx.fillText(power + "%", attack.pos.x * this.tileW + 2, attack.pos.y * this.tileH + 2 - this.unitOffsetY);
      }
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.tileWithUnit = function(unitId) {
      var tiles;
      tiles = this.tiles.filter(function(tile) {
        return tile.unit !== null && tile.unit.unitId === unitId;
      });
      if (tiles.length !== 0) {
        return tiles[0];
      } else {
        return null;
      }
    };
    AnimatedMap.prototype.getMapArray = function() {
      var mapArray;
      mapArray = {};
      this.tiles.forEach(function(tile) {
        if (mapArray[tile.y] === undefined) {
          mapArray[tile.y] = {};
        }
        return mapArray[tile.y][tile.x] = tile;
      });
      return mapArray;
    };
    AnimatedMap.prototype.interpolateColor = function(baseColor, targetColor, scalar) {
      var color;
      color = {
        r: baseColor.r + scalar * (targetColor.r - baseColor.r),
        g: baseColor.g + scalar * (targetColor.g - baseColor.g),
        b: baseColor.b + scalar * (targetColor.b - baseColor.b)
      };
      return color;
    };
    AnimatedMap.prototype.paintPowerMap = function(powerMap) {
      var color, ctx, maxValuePlayer, neutralColor, playerColor, valueScale, x, y;
      ctx = this.canvas.background.getContext("2d");
      ctx.save();
      ctx.globalAlpha = 0.8;
      neutralColor = this.theme.getPlayerColor(0);
      for (y in powerMap.tiles) {
        for (x in powerMap.tiles[y]) {
          y = parseInt(y);
          x = parseInt(x);
          maxValuePlayer = powerMap.tiles[y][x].maxValuePlayer;
          playerColor = this.theme.getPlayerColor(maxValuePlayer);
          valueScale = (parseFloat(powerMap.tiles[y][x].maxValue) / parseFloat(powerMap.maxValue)) / 2 + 0.5;
          color = this.interpolateColor(neutralColor, playerColor, valueScale);
          ctx.fillStyle = "rgba(" + parseInt(color.r) + "," + parseInt(color.g) + "," + parseInt(color.b) + "," + valueScale + ")";
          this.paintMask(ctx, x, y);
        }
      }
      ctx.restore();
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.paintBorders = function(powerMap) {
      var color, ctx, maxValuePlayer, x, x1, x2, y, y1, y2;
      ctx = this.canvas.background.getContext("2d");
      ctx.save();
      ctx.globalAlpha = 1.0;
      for (y in powerMap.tiles) {
        for (x in powerMap.tiles[y]) {
          y = parseInt(y);
          x = parseInt(x);
          maxValuePlayer = powerMap.tiles[y][x].maxValuePlayer;
          if (maxValuePlayer === 0) {
            continue;
          }
          x1 = x * this.tileW;
          y1 = y * this.tileH - this.unitOffsetY;
          x2 = (x + 1) * this.tileW;
          y2 = (y + 1) * this.tileH - this.unitOffsetY;
          color = this.theme.getPlayerColorString(maxValuePlayer);
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          if (y > 0 && maxValuePlayer !== powerMap.tiles[y - 1][x].maxValuePlayer) {
            ctx.moveTo(x1, y1 + 1);
            ctx.lineTo(x2, y1 + 1);
          }
          if (x > 0 && maxValuePlayer !== powerMap.tiles[y][x - 1].maxValuePlayer) {
            ctx.moveTo(x1 + 1, y1);
            ctx.lineTo(x1 + 1, y2);
          }
          if (y < powerMap.tiles.length - 1 && maxValuePlayer !== powerMap.tiles[y + 1][x].maxValuePlayer) {
            ctx.moveTo(x1, y2 - 1);
            ctx.lineTo(x2, y2 - 1);
          }
          if (x < powerMap.tiles[y].length - 1 && maxValuePlayer !== powerMap.tiles[y][x + 1].maxValuePlayer) {
            ctx.moveTo(x2 - 1, y1);
            ctx.lineTo(x2 - 1, y2);
          }
          ctx.stroke();
          ctx.closePath();
        }
      }
      ctx.restore();
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.paintGrid = function() {
      var ctx, mapSize, x, y;
      ctx = this.canvas.background.getContext("2d");
      ctx.save();
      ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      mapSize = this.getMapSize();
      y = 0;
      while (y < mapSize.h - 1) {
        ctx.moveTo(0, (y + 1) * this.tileH - this.unitOffsetY);
        ctx.lineTo(mapSize.w * this.tileW, (y + 1) * this.tileH - this.unitOffsetY);
        ++y;
      }
      x = 0;
      while (x < mapSize.w - 1) {
        ctx.moveTo((x + 1) * this.tileW, -this.unitOffsetY);
        ctx.lineTo((x + 1) * this.tileW, mapSize.h * this.tileH - this.unitOffsetY);
        ++x;
      }
      ctx.stroke();
      ctx.restore();
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.initEntities = function() {
      var that;
      that = this;
      this.tiles.forEach(function(el) {
        var unit;
        if (el.unit) {
          unit = new MapUnit(el.unit, el.x, el.y, that);
          unit.healthIndicator = new HealthIndicator(unit);
          that.canvas.addEntity(unit);
          that.canvas.addEntity(unit.healthIndicator);
        }
        if (el.capturePoints < 200) {
          el.captureBar = new CaptureBar(el, that);
          return that.canvas.addEntity(el.captureBar);
        }
      });
      return this.canvas.forceRedraw();
    };
    AnimatedMap.prototype.getUnitEntity = function(unitId) {
      var i, u;
      i = 0;
      while (i < this.canvas.entities.length) {
        u = this.canvas.entities[i];
        if (u.unitId === unitId) {
          return u;
        }
        ++i;
      }
      return null;
    };
    AnimatedMap.prototype.showMoveUnit = function(unitId, path, callback) {
      var endPos, i, next, nextPos, pathSegments, prev, prevPos, segmentTime, u;
      u = this.getUnitEntity(unitId);
      endPos = u.hexPos(path[path.length - 1].x, path[path.length - 1].y);
      if (path.length > 1 && this.animate && (u.x !== endPos.e(1) || u.y !== endPos.e(2))) {
        pathSegments = [];
        segmentTime = 1000 / (this.animationSpeed * path.length);
        i = 1;
        while (i < path.length) {
          prev = path[i - 1];
          next = path[i];
          prevPos = u.hexPos(prev.x, prev.y);
          nextPos = u.hexPos(next.x, next.y);
          pathSegments.push(new aja.PositionAnimation(u, prevPos.e(1), prevPos.e(2), nextPos.e(1), nextPos.e(2), segmentTime));
          ++i;
        }
        return this.canvas.addAnimation(new aja.SequentialAnimation(pathSegments, callback));
      } else {
        u.x = endPos.e(1);
        u.y = endPos.e(2);
        this.canvas.redrawEntity(u);
        return typeof callback === "function" ? callback() : void 0;
      }
    };
    AnimatedMap.prototype.moveUnit = function(unitId, tileId, path, callback) {
      var that;
      that = this;
      return this.showMoveUnit(unitId, path, function() {
        var pos, prevTile, t, u;
        u = that.getUnitEntity(unitId);
        prevTile = that.getTile(u.tx, u.ty);
        t = that.getTile(tileId);
        prevTile.unit = null;
        if (t.unit === null) {
          t.unit = u.unit;
        }
        that.canvas.eraseEntity(u);
        u.tx = t.x;
        u.ty = t.y;
        pos = u.hexPos(t.x, t.y);
        u.x = pos.e(1);
        u.y = pos.e(2);
        that.canvas.drawEntity(u);
        return typeof callback === "function" ? callback() : void 0;
      });
    };
    AnimatedMap.prototype.waitUnit = function(unitId, callback) {
      var u;
      u = this.getUnitEntity(unitId);
      u.unit.moved = true;
      this.canvas.redrawEntity(u);
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.showAttack = function(unitId, targetId, damage, callback) {
      var attacker, canvas, damageParts, damageString, direction, doAttack, halfHex, i, n, number, numbers, parts, target, va, vt, vx;
      doAttack = function() {
        target.unit.health -= damage;
        canvas.redrawEntities([target, attacker]);
        return typeof callback === "function" ? callback() : void 0;
      };
      if (damage === null) {
        callback();
        return;
      }
      attacker = this.getUnitEntity(unitId);
      target = this.getUnitEntity(targetId);
      canvas = this.canvas;
      if (attacker !== null && target !== null) {
        if (this.animate) {
          va = $V([attacker.x, attacker.y]);
          vt = $V([target.x, target.y]);
          direction = vt.subtract(va).toUnitVector();
          halfHex = this.xAxis.add(this.yAxis).multiply(0.5);
          vx = $V([halfHex.e(1) * direction.e(1), halfHex.e(2) * direction.e(2)]);
          damageParts = [];
          damageString = "" + damage;
          numbers = [];
          i = 0;
          while (i < damageString.length) {
            n = parseInt(damageString[i]);
            number = new MapDigit(n, target.x - (damageString.length - i) * this.theme.settings.number.width - 2, target.y, this);
            numbers.push(number);
            this.canvas.addEntity(number);
            parts = [];
            parts.push(new aja.PauseAnimation(i * 50 / this.animationSpeed));
            parts.push(new aja.PositionDeltaAnimation(number, 0, -2 * this.theme.settings.image.height / 3, 100 / this.animationSpeed, aja.easing.QuadOut));
            parts.push(new aja.PositionDeltaAnimation(number, 0, 2 * this.theme.settings.image.height / 3, 100 / this.animationSpeed, aja.easing.QuadIn));
            parts.push(new aja.PauseAnimation(200 / this.animationSpeed));
            damageParts.push(new aja.SequentialAnimation(parts));
            ++i;
          }
          damageParts.push(new aja.PauseAnimation(500 / this.animationSpeed));
          parts = [];
          parts.push(new aja.PositionDeltaAnimation(attacker, vx.e(1), vx.e(2), 100 / this.animationSpeed));
          parts.push(new aja.ParallelAnimation(damageParts));
          parts.push(new aja.PositionDeltaAnimation(attacker, -vx.e(1), -vx.e(2), 200 / this.animationSpeed));
          return this.canvas.addAnimation(new aja.SequentialAnimation(parts, function() {
            i = 0;
            while (i < numbers.length) {
              canvas.removeEntity(numbers[i]);
              ++i;
            }
            return doAttack();
          }));
        } else {
          return doAttack();
        }
      }
    };
    AnimatedMap.prototype.attackUnit = function(unitId, targetId, damage, callback) {
      var attacker, canvas;
      attacker = this.getUnitEntity(unitId);
      canvas = this.canvas;
      return this.showAttack(unitId, targetId, damage, function() {
        attacker.unit.moved = true;
        canvas.redrawEntity(attacker);
        return typeof callback === "function" ? callback() : void 0;
      });
    };
    AnimatedMap.prototype.counterattackUnit = function(unitId, targetId, damage, callback) {
      return this.showAttack(unitId, targetId, damage, callback);
    };
    AnimatedMap.prototype.captureTile = function(unitId, tileId, left, callback) {
      var doCapture, t, that, u;
      doCapture = function() {
        if (!t.captureBar) {
          t.captureBar = new CaptureBar(t, that);
          that.canvas.addEntity(t.captureBar);
        }
        t.capturePoints = left;
        t.beingCaptured = true;
        t.captureBar.visible = t.capturePoints < 200;
        u.unit.moved = true;
        that.refresh();
        return typeof callback === "function" ? callback() : void 0;
      };
      u = this.getUnitEntity(unitId);
      t = this.getTile(tileId);
      that = this;
      if (this.animate) {
        return this.canvas.addAnimation(new aja.SequentialAnimation([new aja.PositionDeltaAnimation(u, 0, -this.theme.settings.hex.height / 2, 100 / this.animationSpeed, aja.easing.QuadOut), new aja.PositionDeltaAnimation(u, 0, this.theme.settings.hex.height / 2, 100 / this.animationSpeed, aja.easing.QuadIn)], doCapture));
      } else {
        return doCapture();
      }
    };
    AnimatedMap.prototype.capturedTile = function(unitId, tileId, callback) {
      var anim, doCaptured, t, that, u;
      doCaptured = function() {
        if (!t.captureBar) {
          t.captureBar = new CaptureBar(t, that);
          that.canvas.addEntity(t.captureBar);
        }
        t.capturePoints = 1;
        t.beingCaptured = false;
        t.captureBar.visible = t.capturePoints < 200;
        t.owner = u.unit.owner;
        u.unit.moved = true;
        that.refresh();
        return typeof callback === "function" ? callback() : void 0;
      };
      u = this.getUnitEntity(unitId);
      t = this.getTile(tileId);
      that = this;
      if (this.animate) {
        anim = new aja.SequentialAnimation([new aja.PositionDeltaAnimation(u, 0, -this.theme.settings.hex.height / 2, 100 / this.animationSpeed, aja.easing.QuadOut), new aja.PositionDeltaAnimation(u, 0, this.theme.settings.hex.height / 2, 100 / this.animationSpeed, aja.easing.QuadIn)], doCaptured);
        anim.loops = 3;
        return this.canvas.addAnimation(anim);
      } else {
        return doCaptured();
      }
    };
    AnimatedMap.prototype.deployUnit = function(unitId, callback) {
      var canvas, doDeploy, rumble, u;
      doDeploy = function() {
        u.unit.deployed = true;
        u.unit.moved = true;
        canvas.redrawEntity(u);
        return typeof callback === "function" ? callback() : void 0;
      };
      u = this.getUnitEntity(unitId);
      canvas = this.canvas;
      if (this.animate) {
        rumble = new aja.SequentialAnimation([new aja.PositionDeltaAnimation(u, 0, -this.theme.settings.hex.height / 8, 20 / this.animationSpeed, aja.easing.SineOut), new aja.PositionDeltaAnimation(u, 0, this.theme.settings.hex.height / 8, 20 / this.animationSpeed, aja.easing.SineIn)]);
        rumble.loops = 3;
        return this.canvas.addAnimation(new aja.SequentialAnimation([new aja.PositionDeltaAnimation(u, 0, -this.theme.settings.hex.height / 2, 100 / this.animationSpeed, aja.easing.QuadOut), new aja.PauseAnimation(300 / this.animationSpeed), new aja.PositionDeltaAnimation(u, 0, this.theme.settings.hex.height / 2, 100 / this.animationSpeed, aja.easing.QuadIn), rumble], doDeploy));
      } else {
        return doDeploy();
      }
    };
    AnimatedMap.prototype.undeployUnit = function(unitId, callback) {
      var canvas, doUndeploy, u;
      doUndeploy = function() {
        u.unit.deployed = false;
        u.unit.moved = true;
        canvas.redrawEntity(u);
        return typeof callback === "function" ? callback() : void 0;
      };
      u = this.getUnitEntity(unitId);
      canvas = this.canvas;
      if (this.animate) {
        return this.canvas.addAnimation(new aja.SequentialAnimation([new aja.PositionDeltaAnimation(u, 0, -this.theme.settings.hex.height / 4, 50 / this.animationSpeed, aja.easing.QuadOut), new aja.PositionDeltaAnimation(u, 0, this.theme.settings.hex.height / 4, 50 / this.animationSpeed, aja.easing.QuadIn)], doUndeploy));
      } else {
        return doUndeploy();
      }
    };
    AnimatedMap.prototype.loadUnit = function(unitId, carrierId, callback) {
      var carrier, u;
      u = this.getUnitEntity(unitId);
      carrier = this.getUnitEntity(carrierId);
      carrier.unit.carriedUnits.push(u.unit);
      u.unit.moved = true;
      this.canvas.removeEntity(u);
      this.canvas.removeEntity(u.healthIndicator);
      this.canvas.redrawEntity(carrier);
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.unloadUnit = function(unitId, carrierId, tileId, callback) {
      var carrier, t, u, unit;
      t = this.getTile(tileId);
      carrier = this.getUnitEntity(carrierId);
      unit = carrier.unit.carriedUnits.filter(function(unit) {
        return unit.unitId === unitId;
      })[0];
      if (unit === undefined) {
        throw "ERROR: Unit not inside the carrier!";
      }
      carrier.unit.carriedUnits = carrier.unit.carriedUnits.filter(function(unit) {
        return unit.unitId !== unitId;
      });
      u = new MapUnit(unit, t.x, t.y, this);
      u.healthIndicator = new HealthIndicator(u);
      t.unit = u.unit;
      unit.moved = true;
      carrier.unit.moved = true;
      if (this.animate) {
        this.canvas.addAnimation(new aja.PositionAnimation(u, carrier.x, carrier.y, u.x, u.y, 200 / this.animationSpeed, aja.easing.Linear, callback));
        u.x = carrier.x;
        u.y = carrier.y;
      }
      this.canvas.redrawEntity(carrier);
      this.canvas.addEntity(u);
      return this.canvas.addEntity(u.healthIndicator);
    };
    AnimatedMap.prototype.destroyUnit = function(unitId, callback) {
      var canvas, doDestroy, t, u;
      doDestroy = function() {
        canvas.removeEntity(u);
        canvas.removeEntity(u.healthIndicator);
        t.unit = null;
        return typeof callback === "function" ? callback() : void 0;
      };
      u = this.getUnitEntity(unitId);
      t = this.getTile(u.tx, u.ty);
      canvas = this.canvas;
      if (this.animate) {
        u.effects = [new aja.OpacityEffect];
        u.opacity = 1.0;
        return this.canvas.addAnimation(new aja.NumberAnimation(u, {
          opacity: {
            from: 1.0,
            to: 0.0
          }
        }, 500 / this.animationSpeed, aja.easing.SineIn, doDestroy));
      } else {
        return doDestroy();
      }
    };
    AnimatedMap.prototype.repairUnit = function(unitId, newHealth, callback) {
      var change, changeString, i, n, u, _fn, _i, _len,
        _this = this;
      u = this.getUnitEntity(unitId);
      change = newHealth - u.unit.health;
      if (change > 0 && this.animate) {
        changeString = "" + change;
        _fn = function(n, i) {
          var anim, number;
          n = parseInt(n);
          number = new MapDigit(n, u.x - (changeString.length - i) * _this.theme.settings.number.width, u.y, _this);
          number.effects = [new aja.OpacityEffect];
          number.opacity = 1.0;
          _this.canvas.addEntity(number);
          anim = new aja.NumberAnimation(number, {
            y: {
              delta: -32
            },
            opacity: 0.0
          }, 1000 / _this.animationSpeed, aja.easing.QuadIn, function() {
            return _this.canvas.removeEntity(number);
          });
          return _this.canvas.addAnimation(anim);
        };
        for (i = _i = 0, _len = changeString.length; _i < _len; i = ++_i) {
          n = changeString[i];
          _fn(n, i);
        }
      }
      u.unit.health = newHealth;
      this.canvas.redrawEntity(u);
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.buildUnit = function(tileId, unit, callback) {
      var t, u;
      t = this.getTile(tileId);
      t.unit = unit;
      unit.health = 100;
      unit.deployed = false;
      unit.moved = true;
      unit.carriedUnits = [];
      u = new MapUnit(unit, t.x, t.y, this);
      u.healthIndicator = new HealthIndicator(u);
      if (this.animate) {
        u.effects = [new aja.OpacityEffect];
        u.opacity = 0.0;
        this.canvas.addAnimation(new aja.NumberAnimation(u, {
          opacity: {
            from: 0.0,
            to: 1.0
          }
        }, 500 / this.animationSpeed, aja.easing.SineIn, callback));
        this.canvas.addEntity(u);
        return this.canvas.addEntity(u.healthIndicator);
      } else {
        this.canvas.addEntity(u);
        this.canvas.addEntity(u.healthIndicator);
        return callback();
      }
    };
    AnimatedMap.prototype.regenerateCapturePointsTile = function(tileId, newCapturePoints, callback) {
      var t;
      t = this.getTile(tileId);
      if (!t.captureBar) {
        t.captureBar = new CaptureBar(t, this);
        this.canvas.addEntity(t.captureBar);
      }
      t.captureBar.visible = t.capturePoints < 200;
      t.capturePoints = newCapturePoints;
      t.beingCaptured = false;
      this.refresh();
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.produceFundsTile = function(tileId, callback) {
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.beginTurn = function(player, callback) {
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.endTurn = function(player, callback) {
      this.tiles.forEach(function(el) {
        if (el.unit) {
          return el.unit.moved = false;
        }
      });
      this.refresh();
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.turnTimeout = function(player, callback) {
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.finished = function(winner, callback) {
      return typeof callback === "function" ? callback() : void 0;
    };
    AnimatedMap.prototype.surrender = function(player, callback) {
      var that;
      that = this;
      this.tiles.forEach(function(tile) {
        if (tile.owner === player) {
          tile.owner = 0;
        }
        if (tile.unit !== null && tile.unit.owner === player) {
          return tile.unit.owner = 0;
        }
      });
      this.refresh();
      return typeof callback === "function" ? callback() : void 0;
    };
    MapUnit = (function() {

      function MapUnit(unit, tx, ty, map) {
        this.unit = unit;
        this.tx = tx;
        this.ty = ty;
        this.map = map;
        this.setToHex(this.tx, this.ty);
        this.unitId = unit.unitId;
      }

      return MapUnit;

    })();
    MapDigit = (function() {

      function MapDigit(n, x, y, map) {
        this.x = x;
        this.y = y;
        this.map = map;
        this.coord = map.theme.getHealthNumberCoordinates(n);
        this.z = 2;
      }

      return MapDigit;

    })();
    Overlay = (function() {

      function Overlay(map) {
        this.canvas = document.createElement("canvas");
        this.resize(map.canvas.width, map.canvas.height);
      }

      return Overlay;

    })();
    CaptureBar = (function() {

      function CaptureBar(tile, map) {
        var tileCoords;
        this.tile = tile;
        this.map = map;
        tileCoords = this.map.hex2rectCoords(tile.x, tile.y);
        this.x = tileCoords.e(1);
        this.y = tileCoords.e(2) - (this.map.theme.settings.image.height - this.map.theme.settings.hex.height) + this.map.theme.getTileOffset(tile.type, tile.subtype, tile.owner);
        this.z = 1;
      }

      return CaptureBar;

    })();
    HealthIndicator = (function() {

      function HealthIndicator(mapUnit) {
        this.mapUnit = mapUnit;
        this.z = 1;
      }

      return HealthIndicator;

    })();
    MapUnit.prototype.hexPos = function(x, y) {
      var pos, unitPos;
      pos = this.map.hex2rectCoords(x, y);
      unitPos = $V([pos.e(1), pos.e(2) - (this.map.theme.settings.image.height - this.map.theme.settings.hex.height)]);
      return unitPos;
    };
    MapUnit.prototype.setToHex = function(x, y) {
      var pos;
      pos = this.hexPos(x, y);
      this.x = pos.e(1);
      return this.y = pos.e(2);
    };
    MapUnit.prototype.rect = function(ctx) {
      return {
        x: this.x,
        y: this.y,
        w: this.map.theme.settings.image.width,
        h: this.map.theme.settings.image.height
      };
    };
    MapUnit.prototype.draw = function(ctx) {
      var coord, deployCoord, freeCoords, i, occupiedCoords, slotCoords, sprites, unitType, _results;
      sprites = (this.unit.moved ? this.map.spritesMoved : this.map.sprites);
      coord = (this.unit ? this.map.theme.getUnitCoordinates(this.unit.type, this.unit.owner) : null);
      if (coord) {
        ctx.drawImage(sprites, this.map.theme.getSheetCoordinate(coord.x), this.map.theme.getSheetCoordinate(coord.y), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.width), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.height), this.x, this.y, this.map.theme.settings.image.width, this.map.theme.settings.image.height);
      }
      if (this.unit.deployed) {
        deployCoord = this.map.theme.getDeployEmblemCoordinates();
        ctx.drawImage(sprites, this.map.theme.getSheetCoordinate(deployCoord.x), this.map.theme.getSheetCoordinate(deployCoord.y), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.width), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.height), this.x, this.y, this.map.theme.settings.image.width, this.map.theme.settings.image.height);
      }
      if (this.map.rules) {
        unitType = this.map.rules.units[this.unit.type];
        if (unitType.carryNum > 0) {
          freeCoords = this.map.theme.getCoordinates(this.map.theme.settings.carrierSlot.freeSlotName);
          occupiedCoords = this.map.theme.getCoordinates(this.map.theme.settings.carrierSlot.occupiedSlotName);
          i = 0;
          _results = [];
          while (i < unitType.carryNum) {
            slotCoords = (i < this.unit.carriedUnits.length ? occupiedCoords : freeCoords);
            ctx.drawImage(this.map.sprites, this.map.theme.getSheetCoordinate(slotCoords.x), this.map.theme.getSheetCoordinate(slotCoords.y), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.width), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.height), this.x, this.y - i * this.map.theme.settings.carrierSlot.slotHeight, this.map.theme.settings.image.width, this.map.theme.settings.image.height);
            _results.push(++i);
          }
          return _results;
        }
      }
    };
    MapDigit.prototype.draw = function(ctx) {
      return ctx.drawImage(this.map.sprites, this.map.theme.getSheetCoordinate(this.coord.x), this.map.theme.getSheetCoordinate(this.coord.y), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.width), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.height), this.x, this.y, this.map.theme.settings.image.width, this.map.theme.settings.image.height);
    };
    MapDigit.prototype.rect = function(ctx) {
      return {
        x: this.x,
        y: this.y,
        w: this.map.theme.settings.image.width,
        h: this.map.theme.settings.image.height
      };
    };
    Overlay.prototype.resize = function(w, h) {
      this.canvas.width = w;
      return this.canvas.height = h;
    };
    Overlay.prototype.draw = function(ctx) {
      return ctx.drawImage(this.canvas, 0, 0);
    };
    Overlay.prototype.rect = function(ctx) {
      return {
        x: 0,
        y: 0,
        w: this.canvas.width,
        h: this.canvas.height
      };
    };
    CaptureBar.prototype.draw = function(ctx) {
      var barCoords, bitCoords, i, numBits, _results;
      if (this.tile.capturePoints < 200) {
        barCoords = this.map.theme.getCoordinates(this.map.theme.settings.captureBar.barName);
        bitCoords = this.map.theme.getCoordinates((this.tile.beingCaptured ? this.map.theme.settings.captureBar.capturingName : this.map.theme.settings.captureBar.recoveringName));
        numBits = Math.ceil(this.map.theme.settings.captureBar.totalBits * this.tile.capturePoints / 200);
        ctx.drawImage(this.map.sprites, this.map.theme.getSheetCoordinate(barCoords.x), this.map.theme.getSheetCoordinate(barCoords.y), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.width), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.height), this.x, this.y, this.map.theme.settings.image.width, this.map.theme.settings.image.height);
        i = 0;
        _results = [];
        while (i < numBits) {
          ctx.drawImage(this.map.sprites, this.map.theme.getSheetCoordinate(bitCoords.x), this.map.theme.getSheetCoordinate(bitCoords.y), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.width), this.map.theme.getSheetCoordinate(this.map.theme.settings.image.height), this.x, this.y - i * this.map.theme.settings.captureBar.bitHeight, this.map.theme.settings.image.width, this.map.theme.settings.image.height);
          _results.push(++i);
        }
        return _results;
      }
    };
    CaptureBar.prototype.rect = function() {
      return {
        x: this.x,
        y: this.y,
        w: this.map.theme.settings.image.width,
        h: this.map.theme.settings.image.height
      };
    };
    HealthIndicator.prototype.draw = function(ctx) {
      var healthString, i, n, numCoord, _results;
      if (this.mapUnit.unit.health < 100 && this.mapUnit.unit.health >= 0) {
        healthString = "" + this.mapUnit.unit.health;
        i = 0;
        _results = [];
        while (i < healthString.length) {
          n = healthString[i];
          numCoord = this.mapUnit.map.theme.getHealthNumberCoordinates(n);
          ctx.drawImage(this.mapUnit.map.sprites, this.mapUnit.map.theme.getSheetCoordinate(numCoord.x), this.mapUnit.map.theme.getSheetCoordinate(numCoord.y), this.mapUnit.map.theme.getSheetCoordinate(this.mapUnit.map.theme.settings.image.width), this.mapUnit.map.theme.getSheetCoordinate(this.mapUnit.map.theme.settings.image.height), this.mapUnit.x - (healthString.length - 1 - i) * (this.mapUnit.map.theme.settings.number.width + 1), this.mapUnit.y, this.mapUnit.map.theme.settings.image.width, this.mapUnit.map.theme.settings.image.height);
          _results.push(++i);
        }
        return _results;
      }
    };
    HealthIndicator.prototype.rect = function() {
      return {
        x: this.mapUnit.x,
        y: this.mapUnit.y,
        w: this.mapUnit.map.theme.settings.image.width,
        h: this.mapUnit.map.theme.settings.image.height
      };
    };
    return AnimatedMap;
  });

}).call(this);
